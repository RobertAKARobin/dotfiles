#!/bin/bash

alias reload='source ~/.bash_profile'
alias sas="sass --style expanded --watch --sourcemap=none"
alias jad="jade -Pw"
alias jek="jekyll serve -w"
alias dnsrefresh="sudo killall -HUP mDNSResponder"
alias math="bc -l"
# BFG clears stuff from Git history
# https://rtyley.github.io/bfg-repo-cleaner/
alias bfg="java -jar ~/bfg.jar"
alias chrome="open -a 'Google Chrome.app'"
alias search="sudo grep -nrilS"
alias json="jq"
alias ports='lsof -i -P | grep -i "listen"'

desk="$HOME/Desktop"
w="$HOME/Programming/web"
games='/usr/share/emacs/22.1/lisp/play/'
useragent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"

COLOR_RED="\033]0;31m"
COLOR_YELLOW="\033[0;33m"
COLOR_GREEN="\033[0;32m"
COLOR_OCHRE="\033[38;5;95m"
COLOR_BLUE="\033[0;34m"
COLOR_WHITE="\033[0;37m"
COLOR_RESET="\033[0m"

function targz(){
  local dir=$(dirname "$1")
  local base=$(basename "$1")
  local fp="$base.tar.gz"
  rm -rf $fp
  tar -cvzf $fp $1
  mv $fp $dir
}

function g(){
  local abbv=$1
  local c=()
  shift
  case "$abbv" in
    a)  c=(add);;
    b)  c=(branch);;
    bDD) # Delete all local branches except the current one 
        git branch | grep -v \* | xargs git branch -D
        c=(branch)
        ;;
    c)  c=(checkout);;
    ca)
        local branch
        local branches=$(git branch -a --format "%(refname:lstrip=2)")
        select_from "$branches" branch
        c=(checkout $branch)
        ;;
    cp) c=(cherry-pick);;
    cpb)
        local branch=$1
        local sha=$(git merge-base HEAD $branch)
        c=(cherry-pick $sha..$branch)
        shift
        ;;
    d)  c=(diff);;
    dg) c=(diff --staged);;
    ds) c=(diff --stat);;
    dt) # diff (be)tween
        c=(diff $1~$2..$1)
        shift
        shift
        ;;
    dts)
        c=(diff --stat $1~$2..$1)
        shift
        shift
        ;;
    f)  c=(fetch);;
    fn)
        git rev-list --all | xargs git grep -i "$@"
        return
        ;;
    l)  c=(log --decorate --graph --pretty=format:"%C(yellow)%h%Creset %C(auto)%d%Creset %Cblue%ar%Creset %Cred%an%Creset %n%w(72,1,2)%s");;
    lf) g l --follow $@; return;;
    la) g l --all $@; return;;
    laf)
        g l --all --follow $2; return;;
    lc) c=(diff --name-only --diff-filter=U);; # List conflicted files
    m)  c=(commit);;
    mm) c=(commit -m);;
    mA) c=(commit --amend -m);;
    mC) c=(commit -C ORIG_HEAD);;
    p)  c=(push);;
    pD) c=(push --delete origin);;
    pu)
        local branch=$(git rev-parse --abbrev-ref HEAD)
        c=(push -u origin $branch)
        ;;
    r)  c=(reset);;
    rc)
        local num_commits=$(git rev-list --count HEAD)
        local message="$(git log -1 --pretty=%B)"
        if [[ $num_commits == 1 ]]; then
          git update-ref -d HEAD
        else
          git reset --soft HEAD~
        fi
        git add .
        c=(commit -C ORIG_HEAD)
        ;;
    s)  c=(status);;
    u)  # undo
        git reset --soft head~$1
        shift
        c=(status)
        ;;
    U)
        git reset --soft head~$1
        shift
        git reset head .
        c=(status)
        ;;
    UH) c=(reset --hard head~$1)
        shift
        ;;
    sh) c=(show $1:./$2)
        shift
        shift
        ;;
    x)  c=(clean -fd);;
    # Clean everything including ignored files
    X)  c=(clean -xfd);;
    # Go to next commit
    ++)
        git log --all --reverse --pretty=%H | grep -A 1 $(git rev-parse HEAD) | tail -n1 | xargs git checkout
        return
        ;;
    # Go to previous commit
    --) c=(checkout HEAD~);;
  esac
  
  if [[ -z $c ]]; then
    c=$abbv
  fi
  echo ">>> git ${c[@]} $@"
  git "${c[@]}" "$@"
}

IGNORE_DIRS="--exclude-dir=node_modules --exclude-dir=jspm_packages --exclude-dir=.git --exclude-dir=tmp"
function ftext(){
  # Search for a substring ($1) in a file tree ($2) and output the file names
  fgrep -irl "$1" ${2:-.} $IGNORE_DIRS "$@"
}
function fline(){
  # Search for a substring ($1) in a file tree ($2) and output the lines on which it appears
  fgrep -ir "$1" ${2:-.} $IGNORE_DIRS "$@"
}
function frx(){
  # Search for a RegEx ($1) in a file tree ($2) and output the file names
  fgrep -irl -E "$1" ${2:-.} $IGNORE_DIRS "$@"
}
function ffile(){
  # Search for a filename matching a RegEx ($1) within a file tree ($2) and output the filename
  local pattern=$1
  local path=$2
  if [[ -z $path ]]; then
    path="."
  fi
  echo ">>> find $path -name $pattern"
  find "$path" -name "$pattern"
}

function happ(){
  heroku apps:destroy $1 --confirm $1
}

function figall(){
  filename="figlet.txt"
  figlist=$(figlist | tail -n +4)
  nl=$'\n'
  output=""
  while read -r font; do
    if [[ "$font" == "Figlet control files in this directory:"* ]]; then
      break
    fi
    output="$output### $font${nl}"
    output="$output$(figlet -f $font $1)${nl}${nl}"
  done <<< "$figlist"
  echo "$output" > $filename
}

function gh(){
  remote=${1:-origin}
  gitpfx='git@github.com:'
  urlpfx='https://www.github.com/'
  url=$(git remote get-url $remote | sed "s~$gitpfx~$urlpfx~" | sed "s~\.git\$~~")
  chrome $url
}

function git_branch(){
  local git_status="$(git status 2> /dev/null)"
  local on_branch="On branch ([^${IFS}]*)"
  local on_commit="HEAD detached at ([^${IFS}]*)"
  local has_unstaged="Changes not staged for commit"
  local has_staged="Changes to be committed"
  local unstaged_char=""
  local staged_char=""
  if [[ $git_status =~ $has_unstaged ]]; then
    unstaged_char=" *"
  fi
  if [[ $git_status =~ $has_staged ]]; then
    staged_char=" +"
  fi
  if [[ $git_status =~ $on_branch ]] || [[ $git_status =~ $on_commit ]]; then
    echo " (${BASH_REMATCH[1]}$unstaged_char$staged_char)"
  fi
}

function ll(){
  echo ""
  echo "----------"
  ls -AF1 $1
  echo "----------"
  echo ""
}

function sizeof(){
  if [[ $1 == "." ]] || [[ -z "$1" ]]; then
    du -hc -d 0 ./.[!.]* ./* 2>/dev/null
  elif [[ $1 == ".." ]]; then
    du -hc -d 0 ../.[!.]* ../* 2>/dev/null
  elif [[ -d $1 ]]; then
    dir=${1%/}
    du -hc -d 0 $dir/.[!.]* $dir/* 2>/dev/null
  else
    du -hc -d 0 $1 2>/dev/null
  fi
}

function sizeofs(){
  sizeof $1 | sort -h
}

function select_from(){
  local options=($1)
  local varname=$2
  local index
  local selection
  for index in "${!options[@]}"; do
    echo -e "$index\t${options[index]}"
  done
  read -n 2 index
  if [[ $index == "q" ]]; then
    return
  fi
  selection="${options[$index]}"
  eval $varname="$selection"
}

#!/bin/bash

alias reload='source ~/.bash_profile'
alias sas="sass --style expanded --watch --sourcemap=none"
alias jad="jade -Pw"
alias jek="jekyll serve -w"
alias dnsrefresh="sudo killall -HUP mDNSResponder"
alias math="bc -l"
# BFG clears stuff from Git history
# https://rtyley.github.io/bfg-repo-cleaner/
alias bfg="java -jar ~/bfg.jar"
alias chrome="open -a 'Google Chrome.app'"
alias search="sudo grep -nrilS"
alias json="jq"
alias ports='lsof -i -P | grep -i "listen"'

function g(){
  local abbv=$1
  local c=()
  shift
  case "$abbv" in
    a)  c=(add);;
    c)  c=(checkout);;
    d)  c=(diff);;
    dg) c=(diff --staged);;
    ds) c=(diff --stat);;
    f)  c=(fetch);;
    l)  c=(log       --decorate --graph --pretty=format:"%C(yellow)%h%Creset %C(auto)%d%Creset %Cblue%ar%Creset %Cred%an%Creset %n%w(72,1,2)%s");;
    la) c=(log --all --decorate --graph --pretty=format:"%C(yellow)%h%Creset %C(auto)%d%Creset %Cblue%ar%Creset %Cred%an%Creset %n%w(72,1,2)%s");;
    m)  c=(commit);;
    mm) c=(commit -m);;
    mA) c=(commit --amend -m);;
    mC) git commit -C ORIG_HEAD;;
    p)  c=(push -u);;
    r)  c=(reset);;
    rc)
        git reset --soft head~
        git add .
        git commit -c ORIG_HEAD
        ;;
    s)  c=(status);;
    u)
        git reset --soft head~
        git status
        ;;
    U)
        git reset --soft head~
        git reset head .
        git status
        ;;
    x)  c=(clean -fd);;
    # Clean everything including ignored files
    X)  c=(clean -xfd);;
    # Go to next commit
    ++) git log --all --reverse --pretty=%H | grep -A 1 $(git rev-parse HEAD) | tail -n1 | xargs git checkout;;
    # Go to previous commit
    --) git checkout HEAD~;;
  esac
  if [[ ! -z $c ]]; then
    git "${c[@]}" "$@"
  fi
}

desk="$HOME/Desktop"
w="$HOME/Programming/web"
games='/usr/share/emacs/22.1/lisp/play/'
useragent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"

COLOR_RED="\033]0;31m"
COLOR_YELLOW="\033[0;33m"
COLOR_GREEN="\033[0;32m"
COLOR_OCHRE="\033[38;5;95m"
COLOR_BLUE="\033[0;34m"
COLOR_WHITE="\033[0;37m"
COLOR_RESET="\033[0m"

IGNORE_DIRS="--exclude-dir={node_modules,jspm_packages,.git,tmp}"
function ftext(){
  fgrep -irl "$1" ${2:-.} $IGNORE_DIRS 
}
function fline(){
  fgrep -ir "$1" ${2:-.} $IGNORE_DIRS
}
function frx(){
  fgrep -irl -E "$1" ${2:-.} $IGNORE_DIRS
}

function happ(){
  heroku apps:destroy $1 --confirm $1
}

function figall(){
  filename="figlet.txt"
  figlist=$(figlist | tail -n +4)
  nl=$'\n'
  output=""
  while read -r font; do
    if [[ "$font" == "Figlet control files in this directory:"* ]]; then
      break
    fi
    output="$output### $font${nl}"
    output="$output$(figlet -f $font $1)${nl}${nl}"
  done <<< "$figlist"
  echo "$output" > $filename
}

function gh(){
  remote=${1:-origin}
  gitpfx='git@github.com:'
  urlpfx='https://www.github.com/'
  url=$(git remote get-url $remote | sed "s~$gitpfx~$urlpfx~" | sed "s~\.git\$~~")
  chrome $url
}

function git_branch(){
  local git_status="$(git status 2> /dev/null)"
  local on_branch="On branch ([^${IFS}]*)"
  local on_commit="HEAD detached at ([^${IFS}]*)"
  local has_unstaged="Changes not staged for commit"
  local has_staged="Changes to be committed"
  local unstaged_char=""
  local staged_char=""
  if [[ $git_status =~ $has_unstaged ]]; then
    unstaged_char=" *"
  fi
  if [[ $git_status =~ $has_staged ]]; then
    staged_char=" +"
  fi
  if [[ $git_status =~ $on_branch ]] || [[ $git_status =~ $on_commit ]]; then
    echo " (${BASH_REMATCH[1]}$unstaged_char$staged_char)"
  fi
}

function grc(){
  num_commits=$(git rev-list --count HEAD)
  message="$(git log -1 --pretty=%B)"
  if [[ $num_commits == 1 ]]; then
    git update-ref -d HEAD
  else
    git reset --soft HEAD~
  fi
  git add .
  git commit -m "$message"
}

function ll(){
  echo ""
  echo "----------"
  ls -AF1 $1
  echo "----------"
  echo ""
}

function sizeof(){
  if [[ $1 == "." ]] || [[ -z "$1" ]]; then
    du -hc -d 0 ./.[!.]* ./* 2>/dev/null
  elif [[ $1 == ".." ]]; then
    du -hc -d 0 ../.[!.]* ../* 2>/dev/null
  elif [[ -d $1 ]]; then
    dir=${1%/}
    du -hc -d 0 $dir/.[!.]* $dir/* 2>/dev/null
  else
    du -hc -d 0 $1 2>/dev/null
  fi
}

function sizeofs(){
  sizeof $1 | sort -h
}
